{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/lib/validation.ts"],"sourcesContent":["import { z } from \"zod\";\r\n\r\n/** Base URL for Home Assistant (http or https, optional port). */\r\nexport const baseUrlSchema = z\r\n  .string()\r\n  .min(1, \"Base URL is required\")\r\n  .url(\"Invalid URL format\")\r\n  .refine(\r\n    (url) => {\r\n      try {\r\n        const u = new URL(url);\r\n        return u.protocol === \"http:\" || u.protocol === \"https:\";\r\n      } catch {\r\n        return false;\r\n      }\r\n    },\r\n    { message: \"URL must use http or https\" }\r\n  );\r\n\r\n/** Long-lived access token (non-empty string). */\r\nexport const tokenSchema = z.string().min(1, \"Token is required\");\r\n\r\n/** Connection payload for HA (base URL + token). */\r\nexport const connectionPayloadSchema = z.object({\r\n  baseUrl: baseUrlSchema,\r\n  token: tokenSchema,\r\n});\r\n\r\n/** Entity filter for discovery (domain list). */\r\nexport const entityFilterSchema = z.object({\r\n  domains: z.array(z.string()).optional(),\r\n  search: z.string().optional(),\r\n});\r\n\r\nexport type BaseUrl = z.infer<typeof baseUrlSchema>;\r\nexport type ConnectionPayload = z.infer<typeof connectionPayloadSchema>;\r\nexport type EntityFilter = z.infer<typeof entityFilterSchema>;\r\n\r\n/**\r\n * Validates connection input. Returns result; never includes token in error messages.\r\n */\r\nexport function validateConnectionInput(input: unknown): { success: true; data: ConnectionPayload } | { success: false; error: string } {\r\n  const result = connectionPayloadSchema.safeParse(input);\r\n  if (result.success) return { success: true, data: result.data };\r\n  const first = result.error.flatten().fieldErrors;\r\n  const msg = first.baseUrl?.[0] ?? first.token?.[0] ?? \"Invalid connection data\";\r\n  return { success: false, error: msg };\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AAGO,MAAM,gBAAgB,yKAAC,CAC3B,MAAM,GACN,GAAG,CAAC,GAAG,wBACP,GAAG,CAAC,sBACJ,MAAM,CACL,CAAC;IACC,IAAI;QACF,MAAM,IAAI,IAAI,IAAI;QAClB,OAAO,EAAE,QAAQ,KAAK,WAAW,EAAE,QAAQ,KAAK;IAClD,EAAE,OAAM;QACN,OAAO;IACT;AACF,GACA;IAAE,SAAS;AAA6B;AAIrC,MAAM,cAAc,yKAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;AAGtC,MAAM,0BAA0B,yKAAC,CAAC,MAAM,CAAC;IAC9C,SAAS;IACT,OAAO;AACT;AAGO,MAAM,qBAAqB,yKAAC,CAAC,MAAM,CAAC;IACzC,SAAS,yKAAC,CAAC,KAAK,CAAC,yKAAC,CAAC,MAAM,IAAI,QAAQ;IACrC,QAAQ,yKAAC,CAAC,MAAM,GAAG,QAAQ;AAC7B;AASO,SAAS,wBAAwB,KAAc;IACpD,MAAM,SAAS,wBAAwB,SAAS,CAAC;IACjD,IAAI,OAAO,OAAO,EAAE,OAAO;QAAE,SAAS;QAAM,MAAM,OAAO,IAAI;IAAC;IAC9D,MAAM,QAAQ,OAAO,KAAK,CAAC,OAAO,GAAG,WAAW;IAChD,MAAM,MAAM,MAAM,OAAO,EAAE,CAAC,EAAE,IAAI,MAAM,KAAK,EAAE,CAAC,EAAE,IAAI;IACtD,OAAO;QAAE,SAAS;QAAO,OAAO;IAAI;AACtC","debugId":null}},
    {"offset": {"line": 111, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/lib/encrypt.ts"],"sourcesContent":["/**\r\n * Server-only encryption for sensitive data (e.g. Home Assistant tokens).\r\n * Uses AES-256-GCM. Never log or send decrypted tokens to the client.\r\n */\r\n\r\nimport { createCipheriv, createDecipheriv, randomBytes, scryptSync } from \"node:crypto\";\r\n\r\nconst ALGORITHM = \"aes-256-gcm\";\r\nconst KEY_LEN = 32;\r\nconst IV_LEN = 16;\r\nconst AUTH_TAG_LEN = 16;\r\nconst SALT_LEN = 32;\r\n\r\nfunction getKey(secret: string): Buffer {\r\n  const salt = process.env.APP_SECRET_SALT ?? \"ha-dashboard-salt-v1\";\r\n  return scryptSync(secret, salt, KEY_LEN);\r\n}\r\n\r\n/**\r\n * Encrypts plaintext. Returns hex string: iv + authTag + ciphertext.\r\n */\r\nexport function encrypt(plaintext: string, secret?: string): string {\r\n  const keySecret = secret ?? process.env.APP_SECRET;\r\n  if (!keySecret || keySecret.length < 16) {\r\n    throw new Error(\"APP_SECRET must be set and at least 16 characters\");\r\n  }\r\n  const key = getKey(keySecret);\r\n  const iv = randomBytes(IV_LEN);\r\n  const cipher = createCipheriv(ALGORITHM, key, iv);\r\n  const encrypted = Buffer.concat([cipher.update(plaintext, \"utf8\"), cipher.final()]);\r\n  const authTag = cipher.getAuthTag();\r\n  return Buffer.concat([iv, authTag, encrypted]).toString(\"hex\");\r\n}\r\n\r\n/**\r\n * Decrypts payload produced by encrypt().\r\n */\r\nexport function decrypt(hexPayload: string, secret?: string): string {\r\n  const keySecret = secret ?? process.env.APP_SECRET;\r\n  if (!keySecret || keySecret.length < 16) {\r\n    throw new Error(\"APP_SECRET must be set and at least 16 characters\");\r\n  }\r\n  const key = getKey(keySecret);\r\n  const buf = Buffer.from(hexPayload, \"hex\");\r\n  if (buf.length < IV_LEN + AUTH_TAG_LEN) {\r\n    throw new Error(\"Invalid encrypted payload\");\r\n  }\r\n  const iv = buf.subarray(0, IV_LEN);\r\n  const authTag = buf.subarray(IV_LEN, IV_LEN + AUTH_TAG_LEN);\r\n  const ciphertext = buf.subarray(IV_LEN + AUTH_TAG_LEN);\r\n  const decipher = createDecipheriv(ALGORITHM, key, iv);\r\n  decipher.setAuthTag(authTag);\r\n  return decipher.update(ciphertext) + decipher.final(\"utf8\");\r\n}\r\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;AAED;;AAEA,MAAM,YAAY;AAClB,MAAM,UAAU;AAChB,MAAM,SAAS;AACf,MAAM,eAAe;AACrB,MAAM,WAAW;AAEjB,SAAS,OAAO,MAAc;IAC5B,MAAM,OAAO,QAAQ,GAAG,CAAC,eAAe,IAAI;IAC5C,OAAO,IAAA,mIAAU,EAAC,QAAQ,MAAM;AAClC;AAKO,SAAS,QAAQ,SAAiB,EAAE,MAAe;IACxD,MAAM,YAAY,UAAU,QAAQ,GAAG,CAAC,UAAU;IAClD,IAAI,CAAC,aAAa,UAAU,MAAM,GAAG,IAAI;QACvC,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,MAAM,OAAO;IACnB,MAAM,KAAK,IAAA,oIAAW,EAAC;IACvB,MAAM,SAAS,IAAA,uIAAc,EAAC,WAAW,KAAK;IAC9C,MAAM,YAAY,OAAO,MAAM,CAAC;QAAC,OAAO,MAAM,CAAC,WAAW;QAAS,OAAO,KAAK;KAAG;IAClF,MAAM,UAAU,OAAO,UAAU;IACjC,OAAO,OAAO,MAAM,CAAC;QAAC;QAAI;QAAS;KAAU,EAAE,QAAQ,CAAC;AAC1D;AAKO,SAAS,QAAQ,UAAkB,EAAE,MAAe;IACzD,MAAM,YAAY,UAAU,QAAQ,GAAG,CAAC,UAAU;IAClD,IAAI,CAAC,aAAa,UAAU,MAAM,GAAG,IAAI;QACvC,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,MAAM,OAAO;IACnB,MAAM,MAAM,OAAO,IAAI,CAAC,YAAY;IACpC,IAAI,IAAI,MAAM,GAAG,SAAS,cAAc;QACtC,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,KAAK,IAAI,QAAQ,CAAC,GAAG;IAC3B,MAAM,UAAU,IAAI,QAAQ,CAAC,QAAQ,SAAS;IAC9C,MAAM,aAAa,IAAI,QAAQ,CAAC,SAAS;IACzC,MAAM,WAAW,IAAA,yIAAgB,EAAC,WAAW,KAAK;IAClD,SAAS,UAAU,CAAC;IACpB,OAAO,SAAS,MAAM,CAAC,cAAc,SAAS,KAAK,CAAC;AACtD","debugId":null}},
    {"offset": {"line": 177, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\nconst globalForPrisma = globalThis as unknown as { prisma: PrismaClient };\r\n\r\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient();\r\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAEjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6IAAY;AAChE,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 190, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/app/api/ha/connection/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\nimport { validateConnectionInput } from \"@/lib/validation\";\r\nimport { encrypt } from \"@/lib/encrypt\";\r\nimport { prisma } from \"@/lib/prisma\";\r\n\r\n/**\r\n * GET /api/ha/connection – Current connection (baseUrl only, never token).\r\n */\r\nexport async function GET() {\r\n  const conn = await prisma.connection.findFirst({\r\n    orderBy: { createdAt: \"desc\" },\r\n    select: { baseUrl: true },\r\n  });\r\n  if (!conn) return NextResponse.json({ baseUrl: null });\r\n  return NextResponse.json({ baseUrl: conn.baseUrl });\r\n}\r\n\r\n/**\r\n * POST /api/ha/connection – Save HA connection (single connection; existing is replaced).\r\n * Body: { baseUrl: string, token: string }. Never return token.\r\n */\r\nexport async function POST(request: Request) {\r\n  let body: unknown;\r\n  try {\r\n    body = await request.json();\r\n  } catch {\r\n    return NextResponse.json({ error: \"Invalid JSON\" }, { status: 400 });\r\n  }\r\n  const validated = validateConnectionInput(body);\r\n  if (!validated.success) {\r\n    return NextResponse.json({ error: validated.error }, { status: 400 });\r\n  }\r\n  try {\r\n    await prisma.connection.deleteMany({});\r\n    const encryptedToken = encrypt(validated.data.token);\r\n    const conn = await prisma.connection.create({\r\n      data: {\r\n        baseUrl: validated.data.baseUrl,\r\n        encryptedToken,\r\n      },\r\n    });\r\n    return NextResponse.json({ connectionId: conn.id });\r\n  } catch (err) {\r\n    return NextResponse.json(\r\n      { error: err instanceof Error ? err.message : \"Failed to save connection\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AAKO,eAAe;IACpB,MAAM,OAAO,MAAM,gIAAM,CAAC,UAAU,CAAC,SAAS,CAAC;QAC7C,SAAS;YAAE,WAAW;QAAO;QAC7B,QAAQ;YAAE,SAAS;QAAK;IAC1B;IACA,IAAI,CAAC,MAAM,OAAO,gJAAY,CAAC,IAAI,CAAC;QAAE,SAAS;IAAK;IACpD,OAAO,gJAAY,CAAC,IAAI,CAAC;QAAE,SAAS,KAAK,OAAO;IAAC;AACnD;AAMO,eAAe,KAAK,OAAgB;IACzC,IAAI;IACJ,IAAI;QACF,OAAO,MAAM,QAAQ,IAAI;IAC3B,EAAE,OAAM;QACN,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAe,GAAG;YAAE,QAAQ;QAAI;IACpE;IACA,MAAM,YAAY,IAAA,qJAAuB,EAAC;IAC1C,IAAI,CAAC,UAAU,OAAO,EAAE;QACtB,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO,UAAU,KAAK;QAAC,GAAG;YAAE,QAAQ;QAAI;IACrE;IACA,IAAI;QACF,MAAM,gIAAM,CAAC,UAAU,CAAC,UAAU,CAAC,CAAC;QACpC,MAAM,iBAAiB,IAAA,kIAAO,EAAC,UAAU,IAAI,CAAC,KAAK;QACnD,MAAM,OAAO,MAAM,gIAAM,CAAC,UAAU,CAAC,MAAM,CAAC;YAC1C,MAAM;gBACJ,SAAS,UAAU,IAAI,CAAC,OAAO;gBAC/B;YACF;QACF;QACA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,cAAc,KAAK,EAAE;QAAC;IACnD,EAAE,OAAO,KAAK;QACZ,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO,eAAe,QAAQ,IAAI,OAAO,GAAG;QAA4B,GAC1E;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}