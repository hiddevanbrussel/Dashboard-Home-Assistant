{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nconst globalForPrisma = globalThis as unknown as { prisma: PrismaClient };\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient();\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAEjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6IAAY;AAChE,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 80, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/lib/encrypt.ts"],"sourcesContent":["/**\n * Server-only encryption for sensitive data (e.g. Home Assistant tokens).\n * Uses AES-256-GCM. Never log or send decrypted tokens to the client.\n */\n\nimport { createCipheriv, createDecipheriv, randomBytes, scryptSync } from \"node:crypto\";\n\nconst ALGORITHM = \"aes-256-gcm\";\nconst KEY_LEN = 32;\nconst IV_LEN = 16;\nconst AUTH_TAG_LEN = 16;\nconst SALT_LEN = 32;\n\nfunction getKey(secret: string): Buffer {\n  const salt = process.env.APP_SECRET_SALT ?? \"ha-dashboard-salt-v1\";\n  return scryptSync(secret, salt, KEY_LEN);\n}\n\n/**\n * Encrypts plaintext. Returns hex string: iv + authTag + ciphertext.\n */\nexport function encrypt(plaintext: string, secret?: string): string {\n  const keySecret = secret ?? process.env.APP_SECRET;\n  if (!keySecret || keySecret.length < 16) {\n    throw new Error(\"APP_SECRET must be set and at least 16 characters\");\n  }\n  const key = getKey(keySecret);\n  const iv = randomBytes(IV_LEN);\n  const cipher = createCipheriv(ALGORITHM, key, iv);\n  const encrypted = Buffer.concat([cipher.update(plaintext, \"utf8\"), cipher.final()]);\n  const authTag = cipher.getAuthTag();\n  return Buffer.concat([iv, authTag, encrypted]).toString(\"hex\");\n}\n\n/**\n * Decrypts payload produced by encrypt().\n */\nexport function decrypt(hexPayload: string, secret?: string): string {\n  const keySecret = secret ?? process.env.APP_SECRET;\n  if (!keySecret || keySecret.length < 16) {\n    throw new Error(\"APP_SECRET must be set and at least 16 characters\");\n  }\n  const key = getKey(keySecret);\n  const buf = Buffer.from(hexPayload, \"hex\");\n  if (buf.length < IV_LEN + AUTH_TAG_LEN) {\n    throw new Error(\"Invalid encrypted payload\");\n  }\n  const iv = buf.subarray(0, IV_LEN);\n  const authTag = buf.subarray(IV_LEN, IV_LEN + AUTH_TAG_LEN);\n  const ciphertext = buf.subarray(IV_LEN + AUTH_TAG_LEN);\n  const decipher = createDecipheriv(ALGORITHM, key, iv);\n  decipher.setAuthTag(authTag);\n  return decipher.update(ciphertext) + decipher.final(\"utf8\");\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;AAED;;AAEA,MAAM,YAAY;AAClB,MAAM,UAAU;AAChB,MAAM,SAAS;AACf,MAAM,eAAe;AACrB,MAAM,WAAW;AAEjB,SAAS,OAAO,MAAc;IAC5B,MAAM,OAAO,QAAQ,GAAG,CAAC,eAAe,IAAI;IAC5C,OAAO,IAAA,mIAAU,EAAC,QAAQ,MAAM;AAClC;AAKO,SAAS,QAAQ,SAAiB,EAAE,MAAe;IACxD,MAAM,YAAY,UAAU,QAAQ,GAAG,CAAC,UAAU;IAClD,IAAI,CAAC,aAAa,UAAU,MAAM,GAAG,IAAI;QACvC,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,MAAM,OAAO;IACnB,MAAM,KAAK,IAAA,oIAAW,EAAC;IACvB,MAAM,SAAS,IAAA,uIAAc,EAAC,WAAW,KAAK;IAC9C,MAAM,YAAY,OAAO,MAAM,CAAC;QAAC,OAAO,MAAM,CAAC,WAAW;QAAS,OAAO,KAAK;KAAG;IAClF,MAAM,UAAU,OAAO,UAAU;IACjC,OAAO,OAAO,MAAM,CAAC;QAAC;QAAI;QAAS;KAAU,EAAE,QAAQ,CAAC;AAC1D;AAKO,SAAS,QAAQ,UAAkB,EAAE,MAAe;IACzD,MAAM,YAAY,UAAU,QAAQ,GAAG,CAAC,UAAU;IAClD,IAAI,CAAC,aAAa,UAAU,MAAM,GAAG,IAAI;QACvC,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,MAAM,OAAO;IACnB,MAAM,MAAM,OAAO,IAAI,CAAC,YAAY;IACpC,IAAI,IAAI,MAAM,GAAG,SAAS,cAAc;QACtC,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,KAAK,IAAI,QAAQ,CAAC,GAAG;IAC3B,MAAM,UAAU,IAAI,QAAQ,CAAC,QAAQ,SAAS;IAC9C,MAAM,aAAa,IAAI,QAAQ,CAAC,SAAS;IACzC,MAAM,WAAW,IAAA,yIAAgB,EAAC,WAAW,KAAK;IAClD,SAAS,UAAU,CAAC;IACpB,OAAO,SAAS,MAAM,CAAC,cAAc,SAAS,KAAK,CAAC;AACtD","debugId":null}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/lib/db.ts"],"sourcesContent":["/**\n * Server-only: get HA connection config from DB (decrypted).\n */\n\nimport { prisma } from \"./prisma\";\nimport { decrypt } from \"./encrypt\";\n\nexport type HaConfigFromDb = { baseUrl: string; token: string };\n\nexport async function getHaConnection(connectionId?: string): Promise<HaConfigFromDb | null> {\n  const conn = connectionId\n    ? await prisma.connection.findUnique({ where: { id: connectionId } })\n    : await prisma.connection.findFirst({ orderBy: { createdAt: \"desc\" } });\n  if (!conn) return null;\n  try {\n    const token = decrypt(conn.encryptedToken);\n    return { baseUrl: conn.baseUrl, token };\n  } catch {\n    return null;\n  }\n}\n"],"names":[],"mappings":"AAAA;;CAEC;;;;AAED;AACA;;;AAIO,eAAe,gBAAgB,YAAqB;IACzD,MAAM,OAAO,eACT,MAAM,gIAAM,CAAC,UAAU,CAAC,UAAU,CAAC;QAAE,OAAO;YAAE,IAAI;QAAa;IAAE,KACjE,MAAM,gIAAM,CAAC,UAAU,CAAC,SAAS,CAAC;QAAE,SAAS;YAAE,WAAW;QAAO;IAAE;IACvE,IAAI,CAAC,MAAM,OAAO;IAClB,IAAI;QACF,MAAM,QAAQ,IAAA,kIAAO,EAAC,KAAK,cAAc;QACzC,OAAO;YAAE,SAAS,KAAK,OAAO;YAAE;QAAM;IACxC,EAAE,OAAM;QACN,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 175, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/lib/ha/rest.ts"],"sourcesContent":["/**\n * Home Assistant REST API client. Use only on the server.\n */\n\nexport type HaRestConfig = {\n  baseUrl: string;\n  token: string;\n};\n\nfunction normalizeBaseUrl(baseUrl: string): string {\n  const u = baseUrl.trim().replace(/\\/+$/, \"\");\n  return u;\n}\n\nasync function haFetch(\n  baseUrl: string,\n  token: string,\n  path: string,\n  options: RequestInit = {}\n): Promise<Response> {\n  const url = `${normalizeBaseUrl(baseUrl)}${path.startsWith(\"/\") ? path : `/${path}`}`;\n  const res = await fetch(url, {\n    ...options,\n    headers: {\n      Authorization: `Bearer ${token}`,\n      \"Content-Type\": \"application/json\",\n      ...options.headers,\n    },\n  });\n  return res;\n}\n\n/**\n * Test connection: GET /api/ (returns \"API running\" when ok).\n */\nexport async function testConnection(config: HaRestConfig): Promise<{ ok: true } | { ok: false; error: string }> {\n  try {\n    const res = await haFetch(config.baseUrl, config.token, \"/api/\");\n    if (!res.ok) {\n      if (res.status === 401) return { ok: false, error: \"Invalid token. Create a new Long-Lived Access Token in Home Assistant.\" };\n      if (res.status === 404) return { ok: false, error: \"API not found. Check the base URL and that Home Assistant is running.\" };\n      return { ok: false, error: `Connection failed: ${res.status} ${res.statusText}` };\n    }\n    const text = await res.text();\n    if (!text.toLowerCase().includes(\"api\")) {\n      return { ok: false, error: \"Unexpected response from Home Assistant.\" };\n    }\n    return { ok: true };\n  } catch (err) {\n    const message = err instanceof Error ? err.message : String(err);\n    if (message.includes(\"fetch failed\") || message.includes(\"ECONNREFUSED\")) {\n      return { ok: false, error: \"Cannot reach Home Assistant. Check base URL and network.\" };\n    }\n    if (message.includes(\"Mixed Content\") || message.includes(\"HTTPS\")) {\n      return { ok: false, error: \"Use HTTPS for the base URL or a reverse proxy to avoid mixed content.\" };\n    }\n    return { ok: false, error: message };\n  }\n}\n\nexport type HaEntity = {\n  entity_id: string;\n  state: string;\n  attributes: Record<string, unknown>;\n  last_changed?: string;\n  last_updated?: string;\n};\n\n/**\n * Fetch all entity states: GET /api/states.\n */\nexport async function getEntities(config: HaRestConfig): Promise<HaEntity[]> {\n  const res = await haFetch(config.baseUrl, config.token, \"/api/states\");\n  if (!res.ok) {\n    throw new Error(`Failed to fetch entities: ${res.status}`);\n  }\n  const data = (await res.json()) as HaEntity[];\n  return Array.isArray(data) ? data : [];\n}\n\nexport type HaArea = {\n  area_id: string;\n  name: string;\n};\n\n/**\n * Fetch area registry via WebSocket (HA has no REST endpoint for areas).\n * Uses config/area_registry/list over WebSocket.\n */\nexport async function getAreas(config: HaRestConfig): Promise<HaArea[]> {\n  const { fetchAreasViaWebSocket } = await import(\"./websocket\");\n  const list = await fetchAreasViaWebSocket(config.baseUrl, config.token);\n  return list.map((a) => ({ area_id: a.area_id, name: a.name }));\n}\n\n/**\n * Call a Home Assistant service (e.g. light.toggle).\n */\nexport async function callService(\n  config: HaRestConfig,\n  domain: string,\n  service: string,\n  data: Record<string, unknown> = {}\n): Promise<{ ok: boolean; error?: string }> {\n  try {\n    const res = await haFetch(\n      config.baseUrl,\n      config.token,\n      `/api/services/${domain}/${service}`,\n      { method: \"POST\", body: JSON.stringify(data) }\n    );\n    if (!res.ok) {\n      const text = await res.text();\n      return { ok: false, error: text || res.statusText };\n    }\n    return { ok: true };\n  } catch (err) {\n    return { ok: false, error: err instanceof Error ? err.message : String(err) };\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 293, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/app/api/ha/media-image/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { getHaConnection } from \"@/lib/db\";\nimport { getEntities } from \"@/lib/ha/rest\";\n\n/**\n * GET /api/ha/media-image?entity_id=media_player.xxx\n * Returns the entity_picture image for the entity (proxied from HA if relative path).\n */\nexport async function GET(request: Request) {\n  const { searchParams } = new URL(request.url);\n  const entityId = searchParams.get(\"entity_id\");\n  if (!entityId) {\n    return NextResponse.json({ error: \"entity_id required\" }, { status: 400 });\n  }\n  const config = await getHaConnection();\n  if (!config) {\n    return NextResponse.json({ error: \"No HA connection\" }, { status: 400 });\n  }\n  try {\n    const entities = await getEntities(config);\n    const entity = entities.find((e) => e.entity_id === entityId);\n    const picture = entity?.attributes?.entity_picture as string | undefined;\n    if (!picture) {\n      return new NextResponse(null, { status: 404 });\n    }\n    const imageUrl = picture.startsWith(\"http\")\n      ? picture\n      : `${config.baseUrl.replace(/\\/+$/, \"\")}${picture.startsWith(\"/\") ? \"\" : \"/\"}${picture}`;\n\n    const res = await fetch(imageUrl, {\n      headers: { Authorization: `Bearer ${config.token}` },\n    });\n    if (!res.ok) {\n      return new NextResponse(null, { status: res.status });\n    }\n    const blob = await res.blob();\n    const contentType = res.headers.get(\"content-type\") || \"image/jpeg\";\n    return new NextResponse(blob, {\n      headers: {\n        \"Content-Type\": contentType,\n        \"Cache-Control\": \"private, max-age=300\",\n      },\n    });\n  } catch {\n    return NextResponse.json({ error: \"Failed to fetch image\" }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAMO,eAAe,IAAI,OAAgB;IACxC,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;IAC5C,MAAM,WAAW,aAAa,GAAG,CAAC;IAClC,IAAI,CAAC,UAAU;QACb,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAqB,GAAG;YAAE,QAAQ;QAAI;IAC1E;IACA,MAAM,SAAS,MAAM,IAAA,qIAAe;IACpC,IAAI,CAAC,QAAQ;QACX,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAmB,GAAG;YAAE,QAAQ;QAAI;IACxE;IACA,IAAI;QACF,MAAM,WAAW,MAAM,IAAA,yIAAW,EAAC;QACnC,MAAM,SAAS,SAAS,IAAI,CAAC,CAAC,IAAM,EAAE,SAAS,KAAK;QACpD,MAAM,UAAU,QAAQ,YAAY;QACpC,IAAI,CAAC,SAAS;YACZ,OAAO,IAAI,gJAAY,CAAC,MAAM;gBAAE,QAAQ;YAAI;QAC9C;QACA,MAAM,WAAW,QAAQ,UAAU,CAAC,UAChC,UACA,GAAG,OAAO,OAAO,CAAC,OAAO,CAAC,QAAQ,MAAM,QAAQ,UAAU,CAAC,OAAO,KAAK,MAAM,SAAS;QAE1F,MAAM,MAAM,MAAM,MAAM,UAAU;YAChC,SAAS;gBAAE,eAAe,CAAC,OAAO,EAAE,OAAO,KAAK,EAAE;YAAC;QACrD;QACA,IAAI,CAAC,IAAI,EAAE,EAAE;YACX,OAAO,IAAI,gJAAY,CAAC,MAAM;gBAAE,QAAQ,IAAI,MAAM;YAAC;QACrD;QACA,MAAM,OAAO,MAAM,IAAI,IAAI;QAC3B,MAAM,cAAc,IAAI,OAAO,CAAC,GAAG,CAAC,mBAAmB;QACvD,OAAO,IAAI,gJAAY,CAAC,MAAM;YAC5B,SAAS;gBACP,gBAAgB;gBAChB,iBAAiB;YACnB;QACF;IACF,EAAE,OAAM;QACN,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAwB,GAAG;YAAE,QAAQ;QAAI;IAC7E;AACF","debugId":null}}]
}