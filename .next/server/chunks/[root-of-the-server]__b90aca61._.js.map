{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\nconst globalForPrisma = globalThis as unknown as { prisma: PrismaClient };\r\n\r\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient();\r\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAEjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6IAAY;AAChE,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 80, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/lib/encrypt.ts"],"sourcesContent":["/**\r\n * Server-only encryption for sensitive data (e.g. Home Assistant tokens).\r\n * Uses AES-256-GCM. Never log or send decrypted tokens to the client.\r\n */\r\n\r\nimport { createCipheriv, createDecipheriv, randomBytes, scryptSync } from \"node:crypto\";\r\n\r\nconst ALGORITHM = \"aes-256-gcm\";\r\nconst KEY_LEN = 32;\r\nconst IV_LEN = 16;\r\nconst AUTH_TAG_LEN = 16;\r\nconst SALT_LEN = 32;\r\n\r\nfunction getKey(secret: string): Buffer {\r\n  const salt = process.env.APP_SECRET_SALT ?? \"ha-dashboard-salt-v1\";\r\n  return scryptSync(secret, salt, KEY_LEN);\r\n}\r\n\r\n/**\r\n * Encrypts plaintext. Returns hex string: iv + authTag + ciphertext.\r\n */\r\nexport function encrypt(plaintext: string, secret?: string): string {\r\n  const keySecret = secret ?? process.env.APP_SECRET;\r\n  if (!keySecret || keySecret.length < 16) {\r\n    throw new Error(\"APP_SECRET must be set and at least 16 characters\");\r\n  }\r\n  const key = getKey(keySecret);\r\n  const iv = randomBytes(IV_LEN);\r\n  const cipher = createCipheriv(ALGORITHM, key, iv);\r\n  const encrypted = Buffer.concat([cipher.update(plaintext, \"utf8\"), cipher.final()]);\r\n  const authTag = cipher.getAuthTag();\r\n  return Buffer.concat([iv, authTag, encrypted]).toString(\"hex\");\r\n}\r\n\r\n/**\r\n * Decrypts payload produced by encrypt().\r\n */\r\nexport function decrypt(hexPayload: string, secret?: string): string {\r\n  const keySecret = secret ?? process.env.APP_SECRET;\r\n  if (!keySecret || keySecret.length < 16) {\r\n    throw new Error(\"APP_SECRET must be set and at least 16 characters\");\r\n  }\r\n  const key = getKey(keySecret);\r\n  const buf = Buffer.from(hexPayload, \"hex\");\r\n  if (buf.length < IV_LEN + AUTH_TAG_LEN) {\r\n    throw new Error(\"Invalid encrypted payload\");\r\n  }\r\n  const iv = buf.subarray(0, IV_LEN);\r\n  const authTag = buf.subarray(IV_LEN, IV_LEN + AUTH_TAG_LEN);\r\n  const ciphertext = buf.subarray(IV_LEN + AUTH_TAG_LEN);\r\n  const decipher = createDecipheriv(ALGORITHM, key, iv);\r\n  decipher.setAuthTag(authTag);\r\n  return decipher.update(ciphertext) + decipher.final(\"utf8\");\r\n}\r\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;AAED;;AAEA,MAAM,YAAY;AAClB,MAAM,UAAU;AAChB,MAAM,SAAS;AACf,MAAM,eAAe;AACrB,MAAM,WAAW;AAEjB,SAAS,OAAO,MAAc;IAC5B,MAAM,OAAO,QAAQ,GAAG,CAAC,eAAe,IAAI;IAC5C,OAAO,IAAA,mIAAU,EAAC,QAAQ,MAAM;AAClC;AAKO,SAAS,QAAQ,SAAiB,EAAE,MAAe;IACxD,MAAM,YAAY,UAAU,QAAQ,GAAG,CAAC,UAAU;IAClD,IAAI,CAAC,aAAa,UAAU,MAAM,GAAG,IAAI;QACvC,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,MAAM,OAAO;IACnB,MAAM,KAAK,IAAA,oIAAW,EAAC;IACvB,MAAM,SAAS,IAAA,uIAAc,EAAC,WAAW,KAAK;IAC9C,MAAM,YAAY,OAAO,MAAM,CAAC;QAAC,OAAO,MAAM,CAAC,WAAW;QAAS,OAAO,KAAK;KAAG;IAClF,MAAM,UAAU,OAAO,UAAU;IACjC,OAAO,OAAO,MAAM,CAAC;QAAC;QAAI;QAAS;KAAU,EAAE,QAAQ,CAAC;AAC1D;AAKO,SAAS,QAAQ,UAAkB,EAAE,MAAe;IACzD,MAAM,YAAY,UAAU,QAAQ,GAAG,CAAC,UAAU;IAClD,IAAI,CAAC,aAAa,UAAU,MAAM,GAAG,IAAI;QACvC,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,MAAM,OAAO;IACnB,MAAM,MAAM,OAAO,IAAI,CAAC,YAAY;IACpC,IAAI,IAAI,MAAM,GAAG,SAAS,cAAc;QACtC,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,KAAK,IAAI,QAAQ,CAAC,GAAG;IAC3B,MAAM,UAAU,IAAI,QAAQ,CAAC,QAAQ,SAAS;IAC9C,MAAM,aAAa,IAAI,QAAQ,CAAC,SAAS;IACzC,MAAM,WAAW,IAAA,yIAAgB,EAAC,WAAW,KAAK;IAClD,SAAS,UAAU,CAAC;IACpB,OAAO,SAAS,MAAM,CAAC,cAAc,SAAS,KAAK,CAAC;AACtD","debugId":null}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/lib/db.ts"],"sourcesContent":["/**\r\n * Server-only: get HA connection config from DB (decrypted).\r\n */\r\n\r\nimport { prisma } from \"./prisma\";\r\nimport { decrypt } from \"./encrypt\";\r\n\r\nexport type HaConfigFromDb = { baseUrl: string; token: string };\r\n\r\nexport async function getHaConnection(connectionId?: string): Promise<HaConfigFromDb | null> {\r\n  const conn = connectionId\r\n    ? await prisma.connection.findUnique({ where: { id: connectionId } })\r\n    : await prisma.connection.findFirst({ orderBy: { createdAt: \"desc\" } });\r\n  if (!conn) return null;\r\n  try {\r\n    const token = decrypt(conn.encryptedToken);\r\n    return { baseUrl: conn.baseUrl, token };\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n"],"names":[],"mappings":"AAAA;;CAEC;;;;AAED;AACA;;;AAIO,eAAe,gBAAgB,YAAqB;IACzD,MAAM,OAAO,eACT,MAAM,gIAAM,CAAC,UAAU,CAAC,UAAU,CAAC;QAAE,OAAO;YAAE,IAAI;QAAa;IAAE,KACjE,MAAM,gIAAM,CAAC,UAAU,CAAC,SAAS,CAAC;QAAE,SAAS;YAAE,WAAW;QAAO;IAAE;IACvE,IAAI,CAAC,MAAM,OAAO;IAClB,IAAI;QACF,MAAM,QAAQ,IAAA,kIAAO,EAAC,KAAK,cAAc;QACzC,OAAO;YAAE,SAAS,KAAK,OAAO;YAAE;QAAM;IACxC,EAAE,OAAM;QACN,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 175, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/lib/ha/rest.ts"],"sourcesContent":["/**\r\n * Home Assistant REST API client. Use only on the server.\r\n */\r\n\r\nexport type HaRestConfig = {\r\n  baseUrl: string;\r\n  token: string;\r\n};\r\n\r\nfunction normalizeBaseUrl(baseUrl: string): string {\r\n  const u = baseUrl.trim().replace(/\\/+$/, \"\");\r\n  return u;\r\n}\r\n\r\nasync function haFetch(\r\n  baseUrl: string,\r\n  token: string,\r\n  path: string,\r\n  options: RequestInit = {}\r\n): Promise<Response> {\r\n  const url = `${normalizeBaseUrl(baseUrl)}${path.startsWith(\"/\") ? path : `/${path}`}`;\r\n  const res = await fetch(url, {\r\n    ...options,\r\n    headers: {\r\n      Authorization: `Bearer ${token}`,\r\n      \"Content-Type\": \"application/json\",\r\n      ...options.headers,\r\n    },\r\n  });\r\n  return res;\r\n}\r\n\r\n/**\r\n * Test connection: GET /api/ (returns \"API running\" when ok).\r\n */\r\nexport async function testConnection(config: HaRestConfig): Promise<{ ok: true } | { ok: false; error: string }> {\r\n  try {\r\n    const res = await haFetch(config.baseUrl, config.token, \"/api/\");\r\n    if (!res.ok) {\r\n      if (res.status === 401) return { ok: false, error: \"Invalid token. Create a new Long-Lived Access Token in Home Assistant.\" };\r\n      if (res.status === 404) return { ok: false, error: \"API not found. Check the base URL and that Home Assistant is running.\" };\r\n      return { ok: false, error: `Connection failed: ${res.status} ${res.statusText}` };\r\n    }\r\n    const text = await res.text();\r\n    if (!text.toLowerCase().includes(\"api\")) {\r\n      return { ok: false, error: \"Unexpected response from Home Assistant.\" };\r\n    }\r\n    return { ok: true };\r\n  } catch (err) {\r\n    const message = err instanceof Error ? err.message : String(err);\r\n    if (message.includes(\"fetch failed\") || message.includes(\"ECONNREFUSED\")) {\r\n      return { ok: false, error: \"Cannot reach Home Assistant. Check base URL and network.\" };\r\n    }\r\n    if (message.includes(\"Mixed Content\") || message.includes(\"HTTPS\")) {\r\n      return { ok: false, error: \"Use HTTPS for the base URL or a reverse proxy to avoid mixed content.\" };\r\n    }\r\n    return { ok: false, error: message };\r\n  }\r\n}\r\n\r\nexport type HaEntity = {\r\n  entity_id: string;\r\n  state: string;\r\n  attributes: Record<string, unknown>;\r\n  last_changed?: string;\r\n  last_updated?: string;\r\n};\r\n\r\n/**\r\n * Fetch all entity states: GET /api/states.\r\n */\r\nexport async function getEntities(config: HaRestConfig): Promise<HaEntity[]> {\r\n  const res = await haFetch(config.baseUrl, config.token, \"/api/states\");\r\n  if (!res.ok) {\r\n    throw new Error(`Failed to fetch entities: ${res.status}`);\r\n  }\r\n  const data = (await res.json()) as HaEntity[];\r\n  return Array.isArray(data) ? data : [];\r\n}\r\n\r\nexport type HaArea = {\r\n  area_id: string;\r\n  name: string;\r\n};\r\n\r\n/**\r\n * Fetch area registry via WebSocket (HA has no REST endpoint for areas).\r\n * Uses config/area_registry/list over WebSocket.\r\n */\r\nexport async function getAreas(config: HaRestConfig): Promise<HaArea[]> {\r\n  const { fetchAreasViaWebSocket } = await import(\"./websocket\");\r\n  const list = await fetchAreasViaWebSocket(config.baseUrl, config.token);\r\n  return list.map((a) => ({ area_id: a.area_id, name: a.name }));\r\n}\r\n\r\n/**\r\n * Call a Home Assistant service (e.g. light.toggle).\r\n */\r\nexport async function callService(\r\n  config: HaRestConfig,\r\n  domain: string,\r\n  service: string,\r\n  data: Record<string, unknown> = {}\r\n): Promise<{ ok: boolean; error?: string }> {\r\n  try {\r\n    const res = await haFetch(\r\n      config.baseUrl,\r\n      config.token,\r\n      `/api/services/${domain}/${service}`,\r\n      { method: \"POST\", body: JSON.stringify(data) }\r\n    );\r\n    if (!res.ok) {\r\n      const text = await res.text();\r\n      return { ok: false, error: text || res.statusText };\r\n    }\r\n    return { ok: true };\r\n  } catch (err) {\r\n    return { ok: false, error: err instanceof Error ? err.message : String(err) };\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 293, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/app/api/ha/entities/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\nimport { getHaConnection } from \"@/lib/db\";\r\nimport { getEntities } from \"@/lib/ha/rest\";\r\n\r\n/**\r\n * GET /api/ha/entities â€“ List entities from HA. Uses stored connection; no token on client.\r\n * Query: connectionId (optional).\r\n */\r\nexport async function GET(request: Request) {\r\n  const { searchParams } = new URL(request.url);\r\n  const connectionId = searchParams.get(\"connectionId\") ?? undefined;\r\n  const config = await getHaConnection(connectionId);\r\n  if (!config) {\r\n    return NextResponse.json(\r\n      { error: \"No Home Assistant connection. Complete onboarding first.\" },\r\n      { status: 400 }\r\n    );\r\n  }\r\n  try {\r\n    const entities = await getEntities(config);\r\n    return NextResponse.json(entities);\r\n  } catch (err) {\r\n    return NextResponse.json(\r\n      { error: err instanceof Error ? err.message : \"Failed to fetch entities\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAMO,eAAe,IAAI,OAAgB;IACxC,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;IAC5C,MAAM,eAAe,aAAa,GAAG,CAAC,mBAAmB;IACzD,MAAM,SAAS,MAAM,IAAA,qIAAe,EAAC;IACrC,IAAI,CAAC,QAAQ;QACX,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA2D,GACpE;YAAE,QAAQ;QAAI;IAElB;IACA,IAAI;QACF,MAAM,WAAW,MAAM,IAAA,yIAAW,EAAC;QACnC,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,KAAK;QACZ,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO,eAAe,QAAQ,IAAI,OAAO,GAAG;QAA2B,GACzE;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}