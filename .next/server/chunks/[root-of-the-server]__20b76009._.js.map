{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nconst globalForPrisma = globalThis as unknown as { prisma: PrismaClient };\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient();\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAEjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6IAAY;AAChE,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 80, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/lib/encrypt.ts"],"sourcesContent":["/**\n * Server-only encryption for sensitive data (e.g. Home Assistant tokens).\n * Uses AES-256-GCM. Never log or send decrypted tokens to the client.\n */\n\nimport { createCipheriv, createDecipheriv, randomBytes, scryptSync } from \"node:crypto\";\n\nconst ALGORITHM = \"aes-256-gcm\";\nconst KEY_LEN = 32;\nconst IV_LEN = 16;\nconst AUTH_TAG_LEN = 16;\nconst SALT_LEN = 32;\n\nfunction getKey(secret: string): Buffer {\n  const salt = process.env.APP_SECRET_SALT ?? \"ha-dashboard-salt-v1\";\n  return scryptSync(secret, salt, KEY_LEN);\n}\n\n/**\n * Encrypts plaintext. Returns hex string: iv + authTag + ciphertext.\n */\nexport function encrypt(plaintext: string, secret?: string): string {\n  const keySecret = secret ?? process.env.APP_SECRET;\n  if (!keySecret || keySecret.length < 16) {\n    throw new Error(\"APP_SECRET must be set and at least 16 characters\");\n  }\n  const key = getKey(keySecret);\n  const iv = randomBytes(IV_LEN);\n  const cipher = createCipheriv(ALGORITHM, key, iv);\n  const encrypted = Buffer.concat([cipher.update(plaintext, \"utf8\"), cipher.final()]);\n  const authTag = cipher.getAuthTag();\n  return Buffer.concat([iv, authTag, encrypted]).toString(\"hex\");\n}\n\n/**\n * Decrypts payload produced by encrypt().\n */\nexport function decrypt(hexPayload: string, secret?: string): string {\n  const keySecret = secret ?? process.env.APP_SECRET;\n  if (!keySecret || keySecret.length < 16) {\n    throw new Error(\"APP_SECRET must be set and at least 16 characters\");\n  }\n  const key = getKey(keySecret);\n  const buf = Buffer.from(hexPayload, \"hex\");\n  if (buf.length < IV_LEN + AUTH_TAG_LEN) {\n    throw new Error(\"Invalid encrypted payload\");\n  }\n  const iv = buf.subarray(0, IV_LEN);\n  const authTag = buf.subarray(IV_LEN, IV_LEN + AUTH_TAG_LEN);\n  const ciphertext = buf.subarray(IV_LEN + AUTH_TAG_LEN);\n  const decipher = createDecipheriv(ALGORITHM, key, iv);\n  decipher.setAuthTag(authTag);\n  return decipher.update(ciphertext) + decipher.final(\"utf8\");\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;AAED;;AAEA,MAAM,YAAY;AAClB,MAAM,UAAU;AAChB,MAAM,SAAS;AACf,MAAM,eAAe;AACrB,MAAM,WAAW;AAEjB,SAAS,OAAO,MAAc;IAC5B,MAAM,OAAO,QAAQ,GAAG,CAAC,eAAe,IAAI;IAC5C,OAAO,IAAA,mIAAU,EAAC,QAAQ,MAAM;AAClC;AAKO,SAAS,QAAQ,SAAiB,EAAE,MAAe;IACxD,MAAM,YAAY,UAAU,QAAQ,GAAG,CAAC,UAAU;IAClD,IAAI,CAAC,aAAa,UAAU,MAAM,GAAG,IAAI;QACvC,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,MAAM,OAAO;IACnB,MAAM,KAAK,IAAA,oIAAW,EAAC;IACvB,MAAM,SAAS,IAAA,uIAAc,EAAC,WAAW,KAAK;IAC9C,MAAM,YAAY,OAAO,MAAM,CAAC;QAAC,OAAO,MAAM,CAAC,WAAW;QAAS,OAAO,KAAK;KAAG;IAClF,MAAM,UAAU,OAAO,UAAU;IACjC,OAAO,OAAO,MAAM,CAAC;QAAC;QAAI;QAAS;KAAU,EAAE,QAAQ,CAAC;AAC1D;AAKO,SAAS,QAAQ,UAAkB,EAAE,MAAe;IACzD,MAAM,YAAY,UAAU,QAAQ,GAAG,CAAC,UAAU;IAClD,IAAI,CAAC,aAAa,UAAU,MAAM,GAAG,IAAI;QACvC,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,MAAM,OAAO;IACnB,MAAM,MAAM,OAAO,IAAI,CAAC,YAAY;IACpC,IAAI,IAAI,MAAM,GAAG,SAAS,cAAc;QACtC,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,KAAK,IAAI,QAAQ,CAAC,GAAG;IAC3B,MAAM,UAAU,IAAI,QAAQ,CAAC,QAAQ,SAAS;IAC9C,MAAM,aAAa,IAAI,QAAQ,CAAC,SAAS;IACzC,MAAM,WAAW,IAAA,yIAAgB,EAAC,WAAW,KAAK;IAClD,SAAS,UAAU,CAAC;IACpB,OAAO,SAAS,MAAM,CAAC,cAAc,SAAS,KAAK,CAAC;AACtD","debugId":null}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/lib/db.ts"],"sourcesContent":["/**\n * Server-only: get HA connection config from DB (decrypted).\n */\n\nimport { prisma } from \"./prisma\";\nimport { decrypt } from \"./encrypt\";\n\nexport type HaConfigFromDb = { baseUrl: string; token: string };\n\nexport async function getHaConnection(connectionId?: string): Promise<HaConfigFromDb | null> {\n  const conn = connectionId\n    ? await prisma.connection.findUnique({ where: { id: connectionId } })\n    : await prisma.connection.findFirst({ orderBy: { createdAt: \"desc\" } });\n  if (!conn) return null;\n  try {\n    const token = decrypt(conn.encryptedToken);\n    return { baseUrl: conn.baseUrl, token };\n  } catch {\n    return null;\n  }\n}\n"],"names":[],"mappings":"AAAA;;CAEC;;;;AAED;AACA;;;AAIO,eAAe,gBAAgB,YAAqB;IACzD,MAAM,OAAO,eACT,MAAM,gIAAM,CAAC,UAAU,CAAC,UAAU,CAAC;QAAE,OAAO;YAAE,IAAI;QAAa;IAAE,KACjE,MAAM,gIAAM,CAAC,UAAU,CAAC,SAAS,CAAC;QAAE,SAAS;YAAE,WAAW;QAAO;IAAE;IACvE,IAAI,CAAC,MAAM,OAAO;IAClB,IAAI;QACF,MAAM,QAAQ,IAAA,kIAAO,EAAC,KAAK,cAAc;QACzC,OAAO;YAAE,SAAS,KAAK,OAAO;YAAE;QAAM;IACxC,EAAE,OAAM;QACN,OAAO;IACT;AACF","debugId":null}},
    {"offset": {"line": 175, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/lib/ha/rest.ts"],"sourcesContent":["/**\n * Home Assistant REST API client. Use only on the server.\n */\n\nexport type HaRestConfig = {\n  baseUrl: string;\n  token: string;\n};\n\nfunction normalizeBaseUrl(baseUrl: string): string {\n  const u = baseUrl.trim().replace(/\\/+$/, \"\");\n  return u;\n}\n\nasync function haFetch(\n  baseUrl: string,\n  token: string,\n  path: string,\n  options: RequestInit = {}\n): Promise<Response> {\n  const url = `${normalizeBaseUrl(baseUrl)}${path.startsWith(\"/\") ? path : `/${path}`}`;\n  const res = await fetch(url, {\n    ...options,\n    headers: {\n      Authorization: `Bearer ${token}`,\n      \"Content-Type\": \"application/json\",\n      ...options.headers,\n    },\n  });\n  return res;\n}\n\n/**\n * Test connection: GET /api/ (returns \"API running\" when ok).\n */\nexport async function testConnection(config: HaRestConfig): Promise<{ ok: true } | { ok: false; error: string }> {\n  try {\n    const res = await haFetch(config.baseUrl, config.token, \"/api/\");\n    if (!res.ok) {\n      if (res.status === 401) return { ok: false, error: \"Invalid token. Create a new Long-Lived Access Token in Home Assistant.\" };\n      if (res.status === 404) return { ok: false, error: \"API not found. Check the base URL and that Home Assistant is running.\" };\n      return { ok: false, error: `Connection failed: ${res.status} ${res.statusText}` };\n    }\n    const text = await res.text();\n    if (!text.toLowerCase().includes(\"api\")) {\n      return { ok: false, error: \"Unexpected response from Home Assistant.\" };\n    }\n    return { ok: true };\n  } catch (err) {\n    const message = err instanceof Error ? err.message : String(err);\n    if (message.includes(\"fetch failed\") || message.includes(\"ECONNREFUSED\")) {\n      return { ok: false, error: \"Cannot reach Home Assistant. Check base URL and network.\" };\n    }\n    if (message.includes(\"Mixed Content\") || message.includes(\"HTTPS\")) {\n      return { ok: false, error: \"Use HTTPS for the base URL or a reverse proxy to avoid mixed content.\" };\n    }\n    return { ok: false, error: message };\n  }\n}\n\nexport type HaEntity = {\n  entity_id: string;\n  state: string;\n  attributes: Record<string, unknown>;\n  last_changed?: string;\n  last_updated?: string;\n};\n\n/**\n * Fetch all entity states: GET /api/states.\n */\nexport async function getEntities(config: HaRestConfig): Promise<HaEntity[]> {\n  const res = await haFetch(config.baseUrl, config.token, \"/api/states\");\n  if (!res.ok) {\n    throw new Error(`Failed to fetch entities: ${res.status}`);\n  }\n  const data = (await res.json()) as HaEntity[];\n  return Array.isArray(data) ? data : [];\n}\n\nexport type HaArea = {\n  area_id: string;\n  name: string;\n};\n\n/**\n * Fetch area registry via WebSocket (HA has no REST endpoint for areas).\n * Uses config/area_registry/list over WebSocket.\n */\nexport async function getAreas(config: HaRestConfig): Promise<HaArea[]> {\n  const { fetchAreasViaWebSocket } = await import(\"./websocket\");\n  const list = await fetchAreasViaWebSocket(config.baseUrl, config.token);\n  return list.map((a) => ({ area_id: a.area_id, name: a.name }));\n}\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;AAOD,SAAS,iBAAiB,OAAe;IACvC,MAAM,IAAI,QAAQ,IAAI,GAAG,OAAO,CAAC,QAAQ;IACzC,OAAO;AACT;AAEA,eAAe,QACb,OAAe,EACf,KAAa,EACb,IAAY,EACZ,UAAuB,CAAC,CAAC;IAEzB,MAAM,MAAM,GAAG,iBAAiB,WAAW,KAAK,UAAU,CAAC,OAAO,OAAO,CAAC,CAAC,EAAE,MAAM,EAAE;IACrF,MAAM,MAAM,MAAM,MAAM,KAAK;QAC3B,GAAG,OAAO;QACV,SAAS;YACP,eAAe,CAAC,OAAO,EAAE,OAAO;YAChC,gBAAgB;YAChB,GAAG,QAAQ,OAAO;QACpB;IACF;IACA,OAAO;AACT;AAKO,eAAe,eAAe,MAAoB;IACvD,IAAI;QACF,MAAM,MAAM,MAAM,QAAQ,OAAO,OAAO,EAAE,OAAO,KAAK,EAAE;QACxD,IAAI,CAAC,IAAI,EAAE,EAAE;YACX,IAAI,IAAI,MAAM,KAAK,KAAK,OAAO;gBAAE,IAAI;gBAAO,OAAO;YAAyE;YAC5H,IAAI,IAAI,MAAM,KAAK,KAAK,OAAO;gBAAE,IAAI;gBAAO,OAAO;YAAwE;YAC3H,OAAO;gBAAE,IAAI;gBAAO,OAAO,CAAC,mBAAmB,EAAE,IAAI,MAAM,CAAC,CAAC,EAAE,IAAI,UAAU,EAAE;YAAC;QAClF;QACA,MAAM,OAAO,MAAM,IAAI,IAAI;QAC3B,IAAI,CAAC,KAAK,WAAW,GAAG,QAAQ,CAAC,QAAQ;YACvC,OAAO;gBAAE,IAAI;gBAAO,OAAO;YAA2C;QACxE;QACA,OAAO;YAAE,IAAI;QAAK;IACpB,EAAE,OAAO,KAAK;QACZ,MAAM,UAAU,eAAe,QAAQ,IAAI,OAAO,GAAG,OAAO;QAC5D,IAAI,QAAQ,QAAQ,CAAC,mBAAmB,QAAQ,QAAQ,CAAC,iBAAiB;YACxE,OAAO;gBAAE,IAAI;gBAAO,OAAO;YAA2D;QACxF;QACA,IAAI,QAAQ,QAAQ,CAAC,oBAAoB,QAAQ,QAAQ,CAAC,UAAU;YAClE,OAAO;gBAAE,IAAI;gBAAO,OAAO;YAAwE;QACrG;QACA,OAAO;YAAE,IAAI;YAAO,OAAO;QAAQ;IACrC;AACF;AAaO,eAAe,YAAY,MAAoB;IACpD,MAAM,MAAM,MAAM,QAAQ,OAAO,OAAO,EAAE,OAAO,KAAK,EAAE;IACxD,IAAI,CAAC,IAAI,EAAE,EAAE;QACX,MAAM,IAAI,MAAM,CAAC,0BAA0B,EAAE,IAAI,MAAM,EAAE;IAC3D;IACA,MAAM,OAAQ,MAAM,IAAI,IAAI;IAC5B,OAAO,MAAM,OAAO,CAAC,QAAQ,OAAO,EAAE;AACxC;AAWO,eAAe,SAAS,MAAoB;IACjD,MAAM,EAAE,sBAAsB,EAAE,GAAG;IACnC,MAAM,OAAO,MAAM,uBAAuB,OAAO,OAAO,EAAE,OAAO,KAAK;IACtE,OAAO,KAAK,GAAG,CAAC,CAAC,IAAM,CAAC;YAAE,SAAS,EAAE,OAAO;YAAE,MAAM,EAAE,IAAI;QAAC,CAAC;AAC9D","debugId":null}},
    {"offset": {"line": 268, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/app/api/ha/areas/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { getHaConnection } from \"@/lib/db\";\nimport { getAreas } from \"@/lib/ha/rest\";\n\n/**\n * GET /api/ha/areas â€“ List areas from HA. Uses stored connection; no token on client.\n * Query: connectionId (optional).\n */\nexport async function GET(request: Request) {\n  const { searchParams } = new URL(request.url);\n  const connectionId = searchParams.get(\"connectionId\") ?? undefined;\n  const config = await getHaConnection(connectionId);\n  if (!config) {\n    return NextResponse.json(\n      { error: \"No Home Assistant connection. Complete onboarding first.\" },\n      { status: 400 }\n    );\n  }\n  try {\n    const areas = await getAreas(config);\n    return NextResponse.json(areas);\n  } catch (err) {\n    return NextResponse.json(\n      { error: err instanceof Error ? err.message : \"Failed to fetch areas\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAMO,eAAe,IAAI,OAAgB;IACxC,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;IAC5C,MAAM,eAAe,aAAa,GAAG,CAAC,mBAAmB;IACzD,MAAM,SAAS,MAAM,IAAA,qIAAe,EAAC;IACrC,IAAI,CAAC,QAAQ;QACX,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA2D,GACpE;YAAE,QAAQ;QAAI;IAElB;IACA,IAAI;QACF,MAAM,QAAQ,MAAM,IAAA,sIAAQ,EAAC;QAC7B,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,KAAK;QACZ,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO,eAAe,QAAQ,IAAI,OAAO,GAAG;QAAwB,GACtE;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}