{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/lib/ha/websocket.ts"],"sourcesContent":["/**\r\n * Home Assistant WebSocket client. Server-side only.\r\n * Connects to /api/websocket, authenticates, subscribes to state_changed.\r\n */\r\n\r\nimport type { HaEntity } from \"./rest\";\r\n\r\nexport type HaAreaWs = { area_id: string; name: string };\r\n\r\nexport type HaStateChangedEvent = {\r\n  entity_id: string;\r\n  old_state: HaEntity | null;\r\n  new_state: HaEntity | null;\r\n};\r\n\r\nexport type HaWsMessage =\r\n  | { type: \"auth_required\" }\r\n  | { type: \"auth_ok\" }\r\n  | { type: \"auth_invalid\"; message?: string }\r\n  | { type: \"result\"; id: number; success: boolean; result: unknown }\r\n  | { type: \"event\"; id: number; event: { data: { entity_id: string; old_state: unknown; new_state: unknown } } };\r\n\r\nfunction getWsUrl(baseUrl: string): string {\r\n  const u = baseUrl.trim().replace(/\\/+$/, \"\");\r\n  return u.replace(/^http/, \"ws\") + \"/api/websocket\";\r\n}\r\n\r\n/**\r\n * One-shot: connect, auth, send config/area_registry/list, return areas, close.\r\n */\r\nexport async function fetchAreasViaWebSocket(\r\n  baseUrl: string,\r\n  token: string\r\n): Promise<HaAreaWs[]> {\r\n  const WebSocket = (await import(\"ws\")).default;\r\n  const url = getWsUrl(baseUrl);\r\n  const ws = new WebSocket(url);\r\n\r\n  return new Promise((resolve, reject) => {\r\n    const timeout = setTimeout(() => {\r\n      ws.close();\r\n      reject(new Error(\"WebSocket timeout\"));\r\n    }, 15000);\r\n\r\n    let authenticated = false;\r\n    const listId = 1;\r\n\r\n    ws.on(\"message\", (raw: Buffer | string) => {\r\n      let msg: HaWsMessage;\r\n      try {\r\n        msg = JSON.parse(raw.toString()) as HaWsMessage;\r\n      } catch {\r\n        return;\r\n      }\r\n      if (msg.type === \"auth_required\") {\r\n        ws.send(JSON.stringify({ type: \"auth\", access_token: token }));\r\n        return;\r\n      }\r\n      if (msg.type === \"auth_ok\") {\r\n        authenticated = true;\r\n        ws.send(JSON.stringify({ id: listId, type: \"config/area_registry/list\" }));\r\n        return;\r\n      }\r\n      if (msg.type === \"auth_invalid\") {\r\n        clearTimeout(timeout);\r\n        ws.close();\r\n        reject(new Error(msg.message ?? \"WebSocket auth failed\"));\r\n        return;\r\n      }\r\n      if (msg.type === \"result\" && msg.id === listId) {\r\n        clearTimeout(timeout);\r\n        ws.close();\r\n        const result = msg.result;\r\n        const list = Array.isArray(result)\r\n          ? result.map((a: { area_id?: string; name?: string }) => ({\r\n              area_id: a.area_id ?? \"\",\r\n              name: a.name ?? \"\",\r\n            }))\r\n          : [];\r\n        resolve(list);\r\n      }\r\n    });\r\n\r\n    ws.on(\"error\", (err: Error) => {\r\n      clearTimeout(timeout);\r\n      reject(err);\r\n    });\r\n    ws.on(\"close\", () => {\r\n      clearTimeout(timeout);\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Create a WebSocket connection to HA, authenticate, and subscribe to state_changed.\r\n * onEvent is called for each state_changed event. Returns a disconnect function.\r\n */\r\nexport async function connectHaWebSocket(\r\n  baseUrl: string,\r\n  token: string,\r\n  onEvent: (data: HaStateChangedEvent) => void\r\n): Promise<() => void> {\r\n  const WebSocket = (await import(\"ws\")).default;\r\n  const url = getWsUrl(baseUrl);\r\n  const ws = new WebSocket(url);\r\n\r\n  let messageId = 1;\r\n  const pending = new Map<number, { resolve: () => void }>();\r\n\r\n  return new Promise((resolve, reject) => {\r\n    ws.on(\"open\", () => {});\r\n\r\n    ws.on(\"message\", (raw: Buffer | string) => {\r\n      let msg: HaWsMessage;\r\n      try {\r\n        msg = JSON.parse(raw.toString()) as HaWsMessage;\r\n      } catch {\r\n        return;\r\n      }\r\n      if (msg.type === \"auth_required\") {\r\n        ws.send(JSON.stringify({ type: \"auth\", access_token: token }));\r\n        return;\r\n      }\r\n      if (msg.type === \"auth_ok\") {\r\n        ws.send(JSON.stringify({ id: messageId, type: \"subscribe_events\", event_type: \"state_changed\" }));\r\n        const id = messageId++;\r\n        pending.set(id, { resolve: () => {} });\r\n        return;\r\n      }\r\n      if (msg.type === \"auth_invalid\") {\r\n        reject(new Error(msg.message ?? \"WebSocket auth failed\"));\r\n        return;\r\n      }\r\n      if (msg.type === \"result\" && msg.id !== undefined) {\r\n        const p = pending.get(msg.id);\r\n        if (p) {\r\n          pending.delete(msg.id);\r\n          p.resolve();\r\n        }\r\n        if (pending.size === 0) {\r\n          resolve(() => ws.close());\r\n        }\r\n        return;\r\n      }\r\n      if (msg.type === \"event\" && msg.event?.data) {\r\n        const d = msg.event.data;\r\n        onEvent({\r\n          entity_id: d.entity_id,\r\n          old_state: (d.old_state as HaEntity) ?? null,\r\n          new_state: (d.new_state as HaEntity) ?? null,\r\n        });\r\n      }\r\n    });\r\n\r\n    ws.on(\"error\", (err: Error) => reject(err));\r\n    ws.on(\"close\", () => {\r\n      pending.forEach((p) => p.resolve());\r\n    });\r\n  });\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}