{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/lib/validation.ts"],"sourcesContent":["import { z } from \"zod\";\n\n/** Base URL for Home Assistant (http or https, optional port). */\nexport const baseUrlSchema = z\n  .string()\n  .min(1, \"Base URL is required\")\n  .url(\"Invalid URL format\")\n  .refine(\n    (url) => {\n      try {\n        const u = new URL(url);\n        return u.protocol === \"http:\" || u.protocol === \"https:\";\n      } catch {\n        return false;\n      }\n    },\n    { message: \"URL must use http or https\" }\n  );\n\n/** Long-lived access token (non-empty string). */\nexport const tokenSchema = z.string().min(1, \"Token is required\");\n\n/** Connection payload for HA (base URL + token). */\nexport const connectionPayloadSchema = z.object({\n  baseUrl: baseUrlSchema,\n  token: tokenSchema,\n});\n\n/** Entity filter for discovery (domain list). */\nexport const entityFilterSchema = z.object({\n  domains: z.array(z.string()).optional(),\n  search: z.string().optional(),\n});\n\nexport type BaseUrl = z.infer<typeof baseUrlSchema>;\nexport type ConnectionPayload = z.infer<typeof connectionPayloadSchema>;\nexport type EntityFilter = z.infer<typeof entityFilterSchema>;\n\n/**\n * Validates connection input. Returns result; never includes token in error messages.\n */\nexport function validateConnectionInput(input: unknown): { success: true; data: ConnectionPayload } | { success: false; error: string } {\n  const result = connectionPayloadSchema.safeParse(input);\n  if (result.success) return { success: true, data: result.data };\n  const first = result.error.flatten().fieldErrors;\n  const msg = first.baseUrl?.[0] ?? first.token?.[0] ?? \"Invalid connection data\";\n  return { success: false, error: msg };\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AAGO,MAAM,gBAAgB,yKAAC,CAC3B,MAAM,GACN,GAAG,CAAC,GAAG,wBACP,GAAG,CAAC,sBACJ,MAAM,CACL,CAAC;IACC,IAAI;QACF,MAAM,IAAI,IAAI,IAAI;QAClB,OAAO,EAAE,QAAQ,KAAK,WAAW,EAAE,QAAQ,KAAK;IAClD,EAAE,OAAM;QACN,OAAO;IACT;AACF,GACA;IAAE,SAAS;AAA6B;AAIrC,MAAM,cAAc,yKAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG;AAGtC,MAAM,0BAA0B,yKAAC,CAAC,MAAM,CAAC;IAC9C,SAAS;IACT,OAAO;AACT;AAGO,MAAM,qBAAqB,yKAAC,CAAC,MAAM,CAAC;IACzC,SAAS,yKAAC,CAAC,KAAK,CAAC,yKAAC,CAAC,MAAM,IAAI,QAAQ;IACrC,QAAQ,yKAAC,CAAC,MAAM,GAAG,QAAQ;AAC7B;AASO,SAAS,wBAAwB,KAAc;IACpD,MAAM,SAAS,wBAAwB,SAAS,CAAC;IACjD,IAAI,OAAO,OAAO,EAAE,OAAO;QAAE,SAAS;QAAM,MAAM,OAAO,IAAI;IAAC;IAC9D,MAAM,QAAQ,OAAO,KAAK,CAAC,OAAO,GAAG,WAAW;IAChD,MAAM,MAAM,MAAM,OAAO,EAAE,CAAC,EAAE,IAAI,MAAM,KAAK,EAAE,CAAC,EAAE,IAAI;IACtD,OAAO;QAAE,SAAS;QAAO,OAAO;IAAI;AACtC","debugId":null}},
    {"offset": {"line": 105, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/lib/ha/rest.ts"],"sourcesContent":["/**\n * Home Assistant REST API client. Use only on the server.\n */\n\nexport type HaRestConfig = {\n  baseUrl: string;\n  token: string;\n};\n\nfunction normalizeBaseUrl(baseUrl: string): string {\n  const u = baseUrl.trim().replace(/\\/+$/, \"\");\n  return u;\n}\n\nasync function haFetch(\n  baseUrl: string,\n  token: string,\n  path: string,\n  options: RequestInit = {}\n): Promise<Response> {\n  const url = `${normalizeBaseUrl(baseUrl)}${path.startsWith(\"/\") ? path : `/${path}`}`;\n  const res = await fetch(url, {\n    ...options,\n    headers: {\n      Authorization: `Bearer ${token}`,\n      \"Content-Type\": \"application/json\",\n      ...options.headers,\n    },\n  });\n  return res;\n}\n\n/**\n * Test connection: GET /api/ (returns \"API running\" when ok).\n */\nexport async function testConnection(config: HaRestConfig): Promise<{ ok: true } | { ok: false; error: string }> {\n  try {\n    const res = await haFetch(config.baseUrl, config.token, \"/api/\");\n    if (!res.ok) {\n      if (res.status === 401) return { ok: false, error: \"Invalid token. Create a new Long-Lived Access Token in Home Assistant.\" };\n      if (res.status === 404) return { ok: false, error: \"API not found. Check the base URL and that Home Assistant is running.\" };\n      return { ok: false, error: `Connection failed: ${res.status} ${res.statusText}` };\n    }\n    const text = await res.text();\n    if (!text.toLowerCase().includes(\"api\")) {\n      return { ok: false, error: \"Unexpected response from Home Assistant.\" };\n    }\n    return { ok: true };\n  } catch (err) {\n    const message = err instanceof Error ? err.message : String(err);\n    if (message.includes(\"fetch failed\") || message.includes(\"ECONNREFUSED\")) {\n      return { ok: false, error: \"Cannot reach Home Assistant. Check base URL and network.\" };\n    }\n    if (message.includes(\"Mixed Content\") || message.includes(\"HTTPS\")) {\n      return { ok: false, error: \"Use HTTPS for the base URL or a reverse proxy to avoid mixed content.\" };\n    }\n    return { ok: false, error: message };\n  }\n}\n\nexport type HaEntity = {\n  entity_id: string;\n  state: string;\n  attributes: Record<string, unknown>;\n  last_changed?: string;\n  last_updated?: string;\n};\n\n/**\n * Fetch all entity states: GET /api/states.\n */\nexport async function getEntities(config: HaRestConfig): Promise<HaEntity[]> {\n  const res = await haFetch(config.baseUrl, config.token, \"/api/states\");\n  if (!res.ok) {\n    throw new Error(`Failed to fetch entities: ${res.status}`);\n  }\n  const data = (await res.json()) as HaEntity[];\n  return Array.isArray(data) ? data : [];\n}\n\nexport type HaArea = {\n  area_id: string;\n  name: string;\n};\n\n/**\n * Fetch area registry via WebSocket (HA has no REST endpoint for areas).\n * Uses config/area_registry/list over WebSocket.\n */\nexport async function getAreas(config: HaRestConfig): Promise<HaArea[]> {\n  const { fetchAreasViaWebSocket } = await import(\"./websocket\");\n  const list = await fetchAreasViaWebSocket(config.baseUrl, config.token);\n  return list.map((a) => ({ area_id: a.area_id, name: a.name }));\n}\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;AAOD,SAAS,iBAAiB,OAAe;IACvC,MAAM,IAAI,QAAQ,IAAI,GAAG,OAAO,CAAC,QAAQ;IACzC,OAAO;AACT;AAEA,eAAe,QACb,OAAe,EACf,KAAa,EACb,IAAY,EACZ,UAAuB,CAAC,CAAC;IAEzB,MAAM,MAAM,GAAG,iBAAiB,WAAW,KAAK,UAAU,CAAC,OAAO,OAAO,CAAC,CAAC,EAAE,MAAM,EAAE;IACrF,MAAM,MAAM,MAAM,MAAM,KAAK;QAC3B,GAAG,OAAO;QACV,SAAS;YACP,eAAe,CAAC,OAAO,EAAE,OAAO;YAChC,gBAAgB;YAChB,GAAG,QAAQ,OAAO;QACpB;IACF;IACA,OAAO;AACT;AAKO,eAAe,eAAe,MAAoB;IACvD,IAAI;QACF,MAAM,MAAM,MAAM,QAAQ,OAAO,OAAO,EAAE,OAAO,KAAK,EAAE;QACxD,IAAI,CAAC,IAAI,EAAE,EAAE;YACX,IAAI,IAAI,MAAM,KAAK,KAAK,OAAO;gBAAE,IAAI;gBAAO,OAAO;YAAyE;YAC5H,IAAI,IAAI,MAAM,KAAK,KAAK,OAAO;gBAAE,IAAI;gBAAO,OAAO;YAAwE;YAC3H,OAAO;gBAAE,IAAI;gBAAO,OAAO,CAAC,mBAAmB,EAAE,IAAI,MAAM,CAAC,CAAC,EAAE,IAAI,UAAU,EAAE;YAAC;QAClF;QACA,MAAM,OAAO,MAAM,IAAI,IAAI;QAC3B,IAAI,CAAC,KAAK,WAAW,GAAG,QAAQ,CAAC,QAAQ;YACvC,OAAO;gBAAE,IAAI;gBAAO,OAAO;YAA2C;QACxE;QACA,OAAO;YAAE,IAAI;QAAK;IACpB,EAAE,OAAO,KAAK;QACZ,MAAM,UAAU,eAAe,QAAQ,IAAI,OAAO,GAAG,OAAO;QAC5D,IAAI,QAAQ,QAAQ,CAAC,mBAAmB,QAAQ,QAAQ,CAAC,iBAAiB;YACxE,OAAO;gBAAE,IAAI;gBAAO,OAAO;YAA2D;QACxF;QACA,IAAI,QAAQ,QAAQ,CAAC,oBAAoB,QAAQ,QAAQ,CAAC,UAAU;YAClE,OAAO;gBAAE,IAAI;gBAAO,OAAO;YAAwE;QACrG;QACA,OAAO;YAAE,IAAI;YAAO,OAAO;QAAQ;IACrC;AACF;AAaO,eAAe,YAAY,MAAoB;IACpD,MAAM,MAAM,MAAM,QAAQ,OAAO,OAAO,EAAE,OAAO,KAAK,EAAE;IACxD,IAAI,CAAC,IAAI,EAAE,EAAE;QACX,MAAM,IAAI,MAAM,CAAC,0BAA0B,EAAE,IAAI,MAAM,EAAE;IAC3D;IACA,MAAM,OAAQ,MAAM,IAAI,IAAI;IAC5B,OAAO,MAAM,OAAO,CAAC,QAAQ,OAAO,EAAE;AACxC;AAWO,eAAe,SAAS,MAAoB;IACjD,MAAM,EAAE,sBAAsB,EAAE,GAAG;IACnC,MAAM,OAAO,MAAM,uBAAuB,OAAO,OAAO,EAAE,OAAO,KAAK;IACtE,OAAO,KAAK,GAAG,CAAC,CAAC,IAAM,CAAC;YAAE,SAAS,EAAE,OAAO;YAAE,MAAM,EAAE,IAAI;QAAC,CAAC;AAC9D","debugId":null}},
    {"offset": {"line": 198, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/HiddevanBrussel/.cursor/dashboard/src/app/api/ha/test/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { validateConnectionInput } from \"@/lib/validation\";\nimport { testConnection } from \"@/lib/ha/rest\";\n\n/**\n * POST /api/ha/test â€“ Test HA connection with baseUrl + token.\n * Body: { baseUrl: string, token: string }. Never returns token to client.\n */\nexport async function POST(request: Request) {\n  let body: unknown;\n  try {\n    body = await request.json();\n  } catch {\n    return NextResponse.json({ error: \"Invalid JSON\" }, { status: 400 });\n  }\n  const validated = validateConnectionInput(body);\n  if (!validated.success) {\n    return NextResponse.json({ error: validated.error }, { status: 400 });\n  }\n  const result = await testConnection({\n    baseUrl: validated.data.baseUrl,\n    token: validated.data.token,\n  });\n  if (result.ok) {\n    return NextResponse.json({ ok: true });\n  }\n  return NextResponse.json({ ok: false, error: result.error }, { status: 400 });\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAMO,eAAe,KAAK,OAAgB;IACzC,IAAI;IACJ,IAAI;QACF,OAAO,MAAM,QAAQ,IAAI;IAC3B,EAAE,OAAM;QACN,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAe,GAAG;YAAE,QAAQ;QAAI;IACpE;IACA,MAAM,YAAY,IAAA,qJAAuB,EAAC;IAC1C,IAAI,CAAC,UAAU,OAAO,EAAE;QACtB,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO,UAAU,KAAK;QAAC,GAAG;YAAE,QAAQ;QAAI;IACrE;IACA,MAAM,SAAS,MAAM,IAAA,4IAAc,EAAC;QAClC,SAAS,UAAU,IAAI,CAAC,OAAO;QAC/B,OAAO,UAAU,IAAI,CAAC,KAAK;IAC7B;IACA,IAAI,OAAO,EAAE,EAAE;QACb,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,IAAI;QAAK;IACtC;IACA,OAAO,gJAAY,CAAC,IAAI,CAAC;QAAE,IAAI;QAAO,OAAO,OAAO,KAAK;IAAC,GAAG;QAAE,QAAQ;IAAI;AAC7E","debugId":null}}]
}